
/*
 * library use in the program
 */
#include <msp430.h>
#include <string.h>
#include <stdio.h>
/*
 * library for the orders
 */
int i=0;
void InitPort()
{
	P1DIR |= BIT0;

}
void InitUART(void)
	{
		/*
		 * Comunnication UART is located on P1.1 or P1.2
		 */
	 	P1SEL |= (BIT1 + BIT2);                 // P1.1 = RXD, P1.2=TXD
	    P1SEL2 |= (BIT1 + BIT2);                // P1.1 = RXD, P1.2=TXD
	    /*
	     *  2 parameter for the connection UCA0CTL1 & UCACTL0
	     *  UCSSEL_2 USCI clk Source
	     */
	    UCA0CTL1 |= UCSSEL_2;                   // SMCLK

	    /*
	     * Register UCAxBRx : register for CLK =F/dÈbit
	     * UCA0BR0 is initialized
	     */
	    UCA0BR0 = 104;                          // frequency = 1MHz,  baud = 9600
	    UCA0BR1 = 0;                            // 1MHz, 9600

	    /*
	     * UCPEN : Parity enable
	     * UCPAR : Parity select
	     * UCMSB : MSB first (MSB : " Most Significant Bit")
	     */
	    UCA0CTL0 &= ~UCPEN & ~UCPAR & ~UCMSB;
	    /*
	     * UC7BIT : Character Length
	     * UCSPB : Stop Bit select
	     * UCMODEx : USCI mode
	     */
	    UCA0CTL0 &= ~UC7BIT & ~UCSPB & ~UCMODE1;
	    /*
	     * UCMODEx : USCI mode
	     * UCSYNC : Synchronous Mode Enable
	     */
	    UCA0CTL0 &= ~UCMODE0 & ~UCSYNC;
	    /*
	     * UCSWRST : Software Reset Enable
	     */
	    UCA0CTL1 &= ~UCSWRST;                   // **Initialize USCI state machine**
	    /*
	     *
	     */
	    IE2 |= UCA0RXIE;                        // Enable USCI_A0 RX interrupt
	}

void TXdata( unsigned char c )
{
    while (!(IFG2&UCA0TXIFG));  // USCI_A0 TX buffer ready?
    UCA0TXBUF = c;              // TX -> RXed character
}

// Fonction permettant d'afficher plusieurs caractères
// pour avoir la taille des caractères saisis utiliser la commande strln
void afficher_caract(char *point, int taille)
{
	int j=0;
	for (j=0;j<taille;j++)
	{
		TXdata((unsigned char)point[j]);
	}
}

/*
 * main.c
 */
void eteindre_led(void)
{
	P1OUT &= ~BIT0;
}
void allumer_led(void)
{
	P1OUT |= BIT0;
}
void clignoter_led(void)
{
		for(;;)
		{
			P1OUT ^= BIT0;
			for (i=20000; i>=1; i--);
		}
}
void main(void)
{
	//unsigned char c;
    WDTCTL = WDTPW + WDTHOLD;   // Stop WDT
    BCSCTL1 = CALBC1_1MHZ;      // Set DCO to 1Mhz
    DCOCTL = CALDCO_1MHZ;       // Set DCO to 1Mhz


    InitPort();
    InitUART();
    __bis_SR_register(GIE); // interrupts enabled

    while(1);
}

// Echo back RXed character, confirm TX buffer is ready first
#pragma vector=USCIAB0RX_VECTOR
__interrupt void USCI0RX_ISR(void)
{

    unsigned char c;
    char car [100];

    c = UCA0RXBUF;
    sprintf(car,"Veuillez entrez votre choix : %s","\n");
    afficher_caract(car, strlen(car));
    sprintf(car,"menu help : h %s","\n");
    afficher_caract(car, strlen(car));
    sprintf(car,"allumer la led  :  veuillez saisir a %s","\n");
    afficher_caract(car, strlen(car));
    sprintf(car,"eteindre la led : veuillez saisir e %s","\n");
    afficher_caract(car, strlen(car));
    sprintf(car,"clignoter la led veuillez saisir c %s","\n");
    afficher_caract(car, strlen(car));
    switch(c)
    {
    	case 'h':
    	{
    		sprintf(car,"les commandes disponibles sont : %s","\n");
    		afficher_caract(car, strlen(car));
    		sprintf(car,"h %s","\n");
    		afficher_caract(car, strlen(car));
    		sprintf(car,"a %s","\n");
    		afficher_caract(car, strlen(car));
    		sprintf(car,"e %s","\n");
    		afficher_caract(car, strlen(car));
    		sprintf(car,"c: %s","\n");
    		afficher_caract(car, strlen(car));

    	}

    	break;
    	case 'a':
    	{
    		sprintf(car,"la led est allume %s","\n ");
    		afficher_caract(car, strlen(car));
    		TXdata('a');
    		allumer_led();
    	}
    		break;
    	case 'c':
    	{
    		sprintf(car,"la led clignote %s","\n");
    		afficher_caract(car, strlen(car));
    		TXdata('c');
    		clignoter_led();

    	}
    		break;
    	case 'e':
    	{
    		sprintf(car,"la led est eteinte %s","\t %s");
    		afficher_caract(car, strlen(car));
    		TXdata('e');
    		eteindre_led();
    	}
    	 break;

    	 default:
    	   break;
    }
 }
