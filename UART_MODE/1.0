/*
 * library use in the program
 */
#include <msp430.h>
/*
 * library for the orders
 */
int i=0;
void InitUART(void)
	{
		/*
		 * Comunnication UART is located on P1.1 or P1.2
		 */
	 	P1SEL |= (BIT1 + BIT2);                 // P1.1 = RXD, P1.2=TXD
	    P1SEL2 |= (BIT1 + BIT2);                // P1.1 = RXD, P1.2=TXD
	    /*
	     *  2 parameter for the connection UCA0CTL1 & UCACTL0
	     *  UCSSEL_2 USCI clk Source
	     */
	    UCA0CTL1 |= UCSSEL_2;                   // SMCLK

	    /*
	     * Register UCAxBRx : register for CLK =F/dÃˆbit
	     * UCA0BR0 is initialized
	     */
	    UCA0BR0 = 104;                          // frequency = 1MHz,  baud = 9600
	    UCA0BR1 = 0;                            // 1MHz, 9600

	    /*
	     * UCPEN : Parity enable
	     * UCPAR : Parity select
	     * UCMSB : MSB first (MSB : " Most Significant Bit")
	     */
	    UCA0CTL0 &= ~UCPEN & ~UCPAR & ~UCMSB;
	    /*
	     * UC7BIT : Character Length
	     * UCSPB : Stop Bit select
	     * UCMODEx : USCI mode
	     */
	    UCA0CTL0 &= ~UC7BIT & ~UCSPB & ~UCMODE1;
	    /*
	     * UCMODEx : USCI mode
	     * UCSYNC : Synchronous Mode Enable
	     */
	    UCA0CTL0 &= ~UCMODE0 & ~UCSYNC;
	    /*
	     * UCSWRST : Software Reset Enable
	     */
	    UCA0CTL1 &= ~UCSWRST;                   // **Initialize USCI state machine**
	    /*
	     *
	     */
	    IE2 |= UCA0RXIE;                        // Enable USCI_A0 RX interrupt
	}

void TXdata( unsigned char c )
{
    while (!(IFG2&UCA0TXIFG));  // USCI_A0 TX buffer ready?
    UCA0TXBUF = c;              // TX -> RXed character
}

/*
 * main.c
 */
void eteindre_led(void)
{
	P1DIR &= ~BIT0;
}
void allumer_led(void)
{
	P1DIR |= BIT0;
	for(;;)
	{
		P1OUT ^= BIT0;
	}
}
void clignoter_led(void)
{
	P1DIR |= BIT0;
		for(;;)
		{
			P1OUT ^= BIT0;
			for (i=20000; i>=1; i--);
		}
}
void main(void)
{
	//unsigned char c;
    WDTCTL = WDTPW + WDTHOLD;   // Stop WDT
    BCSCTL1 = CALBC1_1MHZ;      // Set DCO to 1Mhz
    DCOCTL = CALDCO_1MHZ;       // Set DCO to 1Mhz

    P1DIR = BIT0;               //

    InitUART();
    __bis_SR_register(GIE); // interrupts enabled

    while(1);
}

// Echo back RXed character, confirm TX buffer is ready first
#pragma vector=USCIAB0RX_VECTOR
__interrupt void USCI0RX_ISR(void)
{
    unsigned char c;

    c = UCA0RXBUF;


    switch(c)
    {
    	case 'h':
    	{
    		TXdata('h');
    		TXdata('e');
    		TXdata('a');
    		TXdata('c');
    	}

    	break;
    	case 'a':
    	{
    		TXdata('a');
    		P1DIR |= BIT0;
    			for(;;)
    			{
    				P1OUT ^= BIT0;
    			}
    		//allumer_led();
    	}
    		break;
    	case 'c':
    	{
    		//clignoter_led();
    		TXdata('c');

    		P1DIR |= BIT0;
    			for(;;)
    			{
    				P1OUT ^= BIT0;
    				for (i=20000; i>=1; i--);
    			}
    	}
    		break;
    	case 'e':
    	{
    		TXdata('e');
    		P1DIR &= ~BIT0;
    		//eteindre_led();
    	}
    	 break;

    	 default:
    	   break;
    }
    }

}
